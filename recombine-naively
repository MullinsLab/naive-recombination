#!/usr/bin/env perl
use strict;
use warnings FATAL => 'all';

=head1 NAME

recombine-naively - Naively recombine input sequences at specified breakpoints

=head1 SYNOPSIS

    recombine-naively --breakpoint=N [--breakpoint=N] [file.fasta ...]
    recombine-naively --help

=head1 DESCRIPTION

Produces naive recombinant sequences (hard breaks, no mutation) from all
possible combinations of input sequences.

Input and output is in the FASTA format.

If no input files are provided, stdin is read.  Output is always to stdout.

Output sequences are named in the following manner:

    foo|@113|bar|@242|baz

where C<foo>, C<bar>, and C<baz> are the input sequence names and C<113> and
C<242> are the breakpoint locations between the adjacent sequences.

=head1 OPTIONS

=over 8

=item B<--breakpoint=N>

=item B<-b N>

Specify a breakpoint should occur I<after> position N.  Positions are 1-based.

This option may be repeated to add multiple breakpoints.  N may also be a
comma-separated list of positions.

The number of breakpoints may not exceed the number of sequences and breakpoint
positions must fall within the length of the shortest sequence.

=item B<--help>

Show this help.

=back

=head1 INSTALLATION

Currently the only supported way is using L<cpanm>:

    cpanm --installdeps .

This will install the dependencies and then you can run this program.

Alternatively, you can install the dependencies in F<cpanfile> manually with
the standard L<cpan> command.

=cut

use Pod::Usage;
use Getopt::Long;
use File::Basename qw< basename >;
use Bio::SeqIO;
use Algorithm::Combinatorics qw< variations_with_repetition >;
use List::AllUtils qw< any min uniq zip pairwise pairgrep >;

my @breakpoints;
GetOptions(
    "breakpoints|b=s" => \@breakpoints,
    "help" => sub {
        pod2usage( -verbose => 99, -sections => [qw( SYNOPSIS DESCRIPTION OPTIONS )] );
    },
) or pod2usage();

@breakpoints = split /,/, join ',', @breakpoints;

pod2usage("No breakpoints specified.  Run with --help to see full usage.")
    unless @breakpoints;

die "Breakpoints must be a positive integer\n"
    if grep { /\D/ or $_ < 1 or $_ != int $_ } @breakpoints;

@breakpoints = sort { $a <=> $b } uniq @breakpoints;

my $input  = Bio::SeqIO->newFh( -fh => \*ARGV,   -format => 'fasta' );
my $output = Bio::SeqIO->newFh( -fh => \*STDOUT, -format => 'fasta' );

my @sequences;
push @sequences, $_ while <$input>;

die "Number of breakpoints (", scalar @breakpoints, ") ",
    "exceeds number of sequences (", scalar @sequences, ")\n"
    if @breakpoints > @sequences;

my $min_seq_length = min map { $_->length } @sequences;
die "Breakpoints must be within the length of the shortest sequence ($min_seq_length).\n"
    if any { $_ >= $min_seq_length } @breakpoints;

my @variations     = variations_with_repetition([0 .. $#sequences], scalar @breakpoints + 1);
my @recombinations = grep {
    my @to   = @$_;                      #  1, 2, 3
    my @from = (-1, @to[0 .. $#to - 1]); # -1, 1, 2
    my @zip  = zip @from, @to;           # -1 => 1, 1 => 2, 2 => 3
    not scalar pairgrep { $a == $b } @zip;
} @variations;

for my $combo (@recombinations) {
    my @seqs = map { $sequences[$_] } @$combo;
    my $recombined = Bio::Seq->new(
        -id => join("|",
            $seqs[0]->id,
            map { sprintf '@%d|%s', $breakpoints[$_], $seqs[$_ + 1]->id } 0 .. $#breakpoints
        ),
    );

    my @subseqs = (@breakpoints, $seqs[-1]->length);
    my $last_bp = 0;
    my $bases;

    for my $seq (@seqs) {
        my $pos  = shift @subseqs;
        $bases  .= $seq->subseq($last_bp + 1, $pos);
        $last_bp = $pos;
    }
    $recombined->seq($bases);
    print { $output } $recombined;
}
